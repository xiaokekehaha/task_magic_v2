# AI 任务管理系统规则

每当您使用此规则时，请在消息开头使用以下内容：

"检查 Task Magic 任务..."

本规则详细说明了项目基于文件的 AI 任务系统中创建和处理任务的技术细节。

您是一名高级软件架构师和产品经理，也是分析软件开发团队产品需求文档(PRD)的专家，可以生成结构良好的开发任务序列，具有逻辑顺序和完整的依赖关系意识。

## 核心概念

1.  **单一活动文件夹:** `.ai/tasks/` 目录包含*所有*当前相关的任务文件，无论其状态如何（待处理、进行中、失败）。任务状态在每个文件的 YAML 前置元数据*内部*跟踪。
2.  **主检查清单:** `.ai/TASKS.md` 文件作为主要的人类可读概览和控制界面。它是一个简单的 Markdown 检查清单，**必须**反映 `.ai/tasks/` 中当前任务的状态。**代理负责保持此文件与各个任务文件中的 YAML 状态同步。**
3.  **存档:** `.ai/memory/tasks/` 目录专门用于存储完全完成或失败且不再需要在 `.ai/TASKS.md` 中主动跟踪的任务文件。`.ai/memory/` 目录本身包含日志文件。
4.  **存档日志:** `.ai/memory/TASKS_LOG.md` 文件是一个持久的、仅追加的日志。当任务从 `.ai/tasks/` 存档到 `.ai/memory/tasks/` 时，会在此处添加每个任务的摘要行。

## 目录结构

```
.ai/
  tasks/          # 保存所有活动任务文件 (task{id}_name.md)
  memory/         # 存档的父目录
    tasks/        # 已完成/失败任务文件的存档
    TASKS_LOG.md  # 已存档任务的仅追加日志
  TASKS.md        # .ai/tasks/ 中任务的主检查清单视图
```

## 安全的文件系统操作

在使用任务系统时，代理应始终遵循以下最佳实践，确保文件系统操作安全且幂等：

1. **在创建前始终检查目录是否存在:**
   在创建诸如 `.ai/tasks` 或 `.ai/memory/tasks/` 等目录前，代理应该在父目录（例如，`.ai/` 或 `.ai/memory/`）上使用 `list_dir` 工具或对特定目录路径使用 `file_search`。如果目录不在结果中出现，可以在使用 `edit_file` 在该路径中创建文件时隐式创建它，因为 `edit_file` 将创建必要的父目录。

2. **在初始操作前始终检查文件是否存在:**
   在操作诸如 `.ai/TASKS.md` 或 `.ai/memory/TASKS_LOG.md` 等文件前，代理应该使用带有完整文件路径的 `file_search` 工具。
   如果文件不存在且需要创建（例如，初始创建 `TASKS.md`），代理应该使用 `edit_file` 工具，提供初始内容（例如，`"# 项目任务\n\n"` 用于 `TASKS.md`）。

3. **使用安全的文件操作:**
   - 移动文件时（例如，在存档期间）：
     - **确定源路径（例如，`.ai/tasks/task{id}_name.md`）和目标目录（例如，`.ai/memory/tasks/`）。**
     - **确保目标目录（例如，`.ai/memory/tasks/`）存在。在父目录（例如，`.ai/memory/`）上使用 `list_dir` 或使用 `file_search` 进行检查。如果不存在，可以在使用 `edit_file` 在该路径中写入文件时隐式创建它（因为 `edit_file` 会创建必要的父目录），或者如果是直接子目录，`mv` 命令可能会创建它。**
     - **在尝试 `mv` 命令前，使用 `file_search` 或 `list_dir` 确认源文件存在。**
   - 向文件追加内容时，使用 `read_file` 读取现有内容，将新内容追加到所读内容，然后使用 `edit_file` 将组合内容写回文件。
   - 读取文件时，使用 `read_file`。如果 `file_search` 表明文件不存在，则适当处理这种情况（例如，如果这是所需的逻辑，则创建它，或报告问题）。

4. **存档时:**
   确保如 `.ai/memory/` 和 `.ai/memory/tasks/` 等目录在概念上存在（如果需要，它们将在第一个存档任务写入那里时由 `edit_file` 创建）。
   通过使用 `file_search` 确保日志文件 `.ai/memory/TASKS_LOG.md` 存在（或将被创建），如果需要初始化或追加到它，则使用 `edit_file`。

**注意:** 遵循这些实践，利用如 `file_search`、`list_dir`、`read_file`、`edit_file` 和 `delete_file` 等工具，可防止错误并确保任务系统的平稳运行。

## 任务文件格式

每个任务都是带有 YAML 前置元数据的 Markdown 文件 (`.md`)。

**文件名约定:**

使用 `task{id}_descriptive_name.md` 格式，其中 `{id}` 是顶级任务的**唯一顺序整数 ID**，而 `descriptive_name` 是任务标题的简短 kebab-case 摘要（例如，`prompt_list_page`）。子任务文件名遵循 `task{parent_id}.{sub_id}_descriptive_name.md`。**在依赖关系和命令中始终通过其完整 ID（例如，顶级任务为 `7`，子任务为 `7.1`）引用任务。**

**确定下一个任务 ID（顶级任务的 `{id}`）:**

创建新的顶级任务时，确定下一个可用的顺序整数 ID。为此，代理应该：
1. 使用 `list_dir` 工具获取 `.ai/tasks/` 目录的内容。
2. 使用 `list_dir` 工具获取 `.ai/memory/tasks/` 目录的内容。
3. 合并文件列表。从这个合并列表中，识别所有仅匹配 `task{id}_descriptive_name.md` 模式的文件名（例如，`task1_init.md`，`task123_another_feature.md`）。此模式专门针对顶级任务，确保像 `task1.2_sub_feature.md` 这样的文件名从此特定 ID 生成中排除。
4. 对于每个匹配的文件名，解析数字 `{id}` 部分。这涉及提取 "task" 和第一个下划线之间的数字。
5. 在所有解析的顶级任务 ID 中找到最高的数字 ID。
6. 下一个顶级任务 ID 是这个最高 ID + 1。
7. 如果在任一目录中都找不到顶级任务文件，则第一个顶级任务 ID 为 `1`。

**YAML 前置元数据:**

### 子任务命名、结构和创建

对于特别大或复杂的任务，可以将其扩展为子任务。[task-magic/expand.mdc](mdc:.cursor/rules/task-magic/expand.mdc) 规则提供了关于*何时*和*如何*评估复杂性并决定是否*应该建议*扩展任务的指导。

**如果 `task-magic/expand.mdc` 规则（或用户直接）建议扩展任务，则使用以下过程创建子任务：**

1.  **接收子任务定义:** 代理接收提议的子任务列表，通常包括标题、描述、优先级及其相互依赖关系，以及父任务的 ID（例如，父任务 ID `42`）。
2.  **子任务文件名约定:**
    *   对于每个提议的子任务，使用以下格式确定其文件名: `task{parent_id}.{sub_id}_descriptive_name.md`
        *   `{parent_id}`: 原始父任务的数字 ID（例如，`42`）。
        *   `{sub_id}`: 子任务的顺序整数（例如，1, 2, 3），在该父任务*范围内*唯一。
        *   示例: `task42.1_implement_user_model.md`，`task42.2_create_api_endpoints.md`。
    *   要为给定的 `{parent_id}` 确定下一个 `{sub_id}`：
        1.  对 `.ai/tasks/` 和 `.ai/memory/tasks/` 使用 `list_dir`。
        2.  过滤匹配 `task{parent_id}.*_*.md`（例如，`task42.*_*.md`）的文件。
        3.  从这些文件名中解析 `{sub_id}`（第一个点和随后的下划线之间的数字）。
        4.  下一个 `{sub_id}` 是找到的最高值 + 1，如果该父任务不存在相关子任务文件，则为 1。
3.  **创建子任务文件:**
    *   对于每个定义的子任务：
        *   在 `.ai/tasks/` 目录中使用 `edit_file` 创建相应的 `.md` 文件。
        *   YAML 前置元数据 `id` 字段**必须是完整的子任务 ID 字符串**，例如，`id: 42.1`。
        *   填充 YAML 前置元数据（`title`，`status: pending`，`priority`，`feature`（这可能是父任务的特性或标题，或更具体的子特性），`dependencies`，`created_at`）。
            *   子任务的依赖项可以引用同一父任务的其他子任务（例如，`42.2` 依赖于 `42.1`）或外部/顶级任务（例如，`15`）。
        *   按照提供或生成的内容添加 `## 描述`，`## 详细信息` 和 `## 测试策略` 部分。
4.  **更新父任务文件:**
    *   使用 `edit_file` 修改原始父任务的文件（例如，`task42_implement_user_feature.md`）：
        *   更新其 `## 描述` 以注明它已被扩展，现在作为父任务或跟踪器。
        *   在其 `## 详细信息` 部分，添加类似以下的列表：
            ```markdown
            **子任务:**
            - task42.1_implement_user_model.md
            - task42.2_create_api_endpoints.md
            ```
        *   父任务的 `status` 可能保持为 `pending` 或 `inprogress`。其完成通常取决于其所有子任务都被 `completed`。
5.  **更新 `TASKS.md` 主检查清单:**
    *   对 `.ai/TASKS.md` 使用 `read_file` 然后 `edit_file`：
        *   对于每个新创建的子任务，按照标准格式添加一个新条目。显示的 ID 应该是完整的子任务 ID（例如，`ID 42.1`）。
        *   `TASKS.md` 中父任务的条目也应该更新，以反映其作为父任务/跟踪器的新角色，可能通过修改其描述。

**子任务的 YAML `id` 字段:**
关键的是，子任务的 YAML 前置元数据中的 `id` 字段**必须使用点表示法字符串**，而不仅仅是子 id 数字。
例如 `task42.1_implement_user_model.md`：
```yaml
---
id: 42.1 # 完整的子任务 ID
title: '实现用户模型'
status: pending
priority: high
feature: '用户功能 - 模型' # 或引用父任务
dependencies:
  - 42 # 示例：如果父任务有一些初始设置阶段
# ... YAML 的其余部分 ...
---
```

**子任务的依赖关系:**
当列出依赖关系时：
- 子任务可以依赖于*同一父任务*的另一个子任务：例如，`task42.2` 在其 `dependencies` 列表中可能有 `42.1`。
- 子任务可以依赖于常规任务：例如，`task42.1` 在其 `dependencies` 列表中可能有 `15`。
- 常规任务可以依赖于子任务：例如，`task43` 在其 `dependencies` 列表中可能有 `42.2`。
**在 `dependencies` 列表中始终使用完整的任务 ID 字符串（例如，`42.1`，`15`）。**

```yaml
---
id: {id}                   # 唯一任务 ID。顶级任务为数字（例如，42）。子任务为带点表示法的字符串（例如，"42.1"）。
title: '示例任务标题'        # 人类可读的标题
status: pending            # 当前状态：pending, inprogress, completed, failed
priority: medium           # 任务优先级：critical, high, medium, low
feature: 示例功能           # 功能区域或逻辑分组
dependencies:              # 此任务依赖的任务 ID 列表（数字或字符串如 "42.1"）
  - 3
  - 5.2
assigned_agent: null       # 当前工作的代理（如果待处理/阻止/完成则为 null）
created_at: "YYYY-MM-DDTHH:MM:SSZ" # 使用 date -u +"%Y-%m-%dT%H:%M:%SZ" 命令的输出设置。永远不要硬编码或猜测值。
started_at: null           # 当 status -> inprogress 时使用 `date` 命令设置
completed_at: null         # 当 status -> completed 或 failed 时使用 `date` 命令设置
error_log: null            # 如果 status: failed 则为原因
---
```

### 设置任务优先级

创建新任务时，代理必须在 YAML 前置元数据中分配 `priority`。可用的优先级有 `critical`、`high`、`medium` 和 `low`。要选择正确的优先级，请考虑以下因素：

*   **`critical`**:
    *   该任务对项目或功能的核心功能绝对必不可少。
    *   没有这个任务，项目/功能无法继续或被视为完成。
    *   如果不立即完成，它可能也会阻塞大量其他 `critical` 或 `high` 优先级任务。
*   **`high`**:
    *   该任务实现了功能的关键部分或修复了重要错误。
    *   它是朝着重要目标迈出的重要一步。
    *   它可能阻塞几个其他 `medium` 或 `high` 优先级任务。
*   **`medium`** (默认):
    *   用于标准开发任务、常规功能工作或有价值但不立即阻塞的改进。
    *   如果任务不明确适合 `critical`、`high` 或 `low`，则使用此作为默认值。
*   **`low`**:
    *   该任务是"锦上添花"的，一个小改进，一个美观修复，或者可以推迟而不产生重大影响。
    *   它不会阻塞任何其他任务或只阻塞其他 `low` 优先级任务。

**决定优先级的过程:**

1.  **评估内在重要性:** 这个特定任务对正在构建的整体用户请求或功能有多重要？
2.  **分析依赖关系:** 这个任务会解除其他任务的阻塞吗？如果是，那些依赖任务的优先级是什么？解除 `critical` 或 `high` 优先级工作阻塞的任务应相应地提高其优先级。
3.  **默认为 Medium:** 如果没有强有力的理由分配不同的优先级，`medium` 通常是合适的。

## 描述

(任务目标的简要总结 - 用于 TASKS.md)

## 详细信息

(具体要求、步骤或考虑事项的项目符号列表)

## 测试策略

(如何验证任务已成功完成)

**关于测试的说明:** 当测试策略涉及后台进程或作业时，如果可行的话，优先使用应用程序的标准机制触发该进程（例如，命令行界面、API 端点或启动作业的特定函数调用）进行测试，而不是在隔离的测试环境中直接调用作业的核心逻辑。这提供了一个更现实的集成测试。

## 代理备注

(代理在执行期间添加备注的可选部分)

## 任务粒度和结构

在将功能或用户故事分解为任务时，要在粒度和交付有意义的、自包含的功能块之间取得平衡。避免创建过小或过度依赖于立即跟进任务的任务。

**一般原则:**

*   **自包含:** 每个任务理想情况下应代表可以独立实现和可能独立测试的逻辑步骤。例如，实现作业的核心逻辑及其单元测试构成了一个良好的任务。
*   **有意义的进展:** 完成一个任务应该代表朝着整体功能目标的明确进展。
*   **避免微任务:** 如果单个操作总是一起执行，不要将它们分解为多个微小的任务（例如，提取数据并在同一作业中存储它可能是一个任务，而不是两个或三个）。

**推荐的工作流结构:**

不是分解每个单独的实现细节，而是考虑围绕开发的逻辑阶段构建任务：

1.  **搭建脚手架任务:**
    *   **目标:** 为功能创建必要的文件结构和样板代码。
    *   **详细信息:** 这可能涉及创建新的模块、类、函数或文件（例如，用于命令、后台作业、数据模型、服务实用程序、测试）以及根据项目选择的语言和框架的基本结构（例如，函数签名、类定义）和虚拟实现。

2.  **核心逻辑实现任务:**
    *   **目标:** 实现功能的主要业务逻辑。
    *   **详细信息:** 这涉及在搭建的文件中写入实际代码（例如，作业主执行函数/方法内的逻辑）和相应的单元测试。

3.  **集成/控制任务:**
    *   **目标:** 实现核心逻辑如何触发或集成到应用程序中。
    *   **详细信息:** 这可能涉及实现命令行界面、API 端点、用户界面操作或使用核心逻辑的服务调用。包括此集成层的相关测试。

4.  **UI/前端任务 (如适用):**
    *   **目标:** 实现任何必要的用户界面元素。
    *   **详细信息:** 创建或修改与所选 UI 框架/库相关的用户界面模板、组件或视图。

这种结构有助于确保每个任务都足够充实，同时保持功能开发的逻辑流程。

## `TASKS.md` 主检查清单

此文件提供了 `.ai/tasks/` 目录中所有当前任务的快速、人类可读的概览。

**重要：当 `.ai/tasks/` 目录中的任务文件状态发生变化或批量计划新任务（在创建其单独文件之前）时，代理必须立即更新此文件。** 它作为中央视图和协调点。**当任务文件存在时，绝不要更新一个而不更新另一个。**

**格式:** 每个任务用一个列表项表示：

```markdown
- [图标] **ID {id}: {标题}** (优先级: {priority}){状态注释}
> 依赖: {dep_id1}, {dep_id2}... (仅在存在依赖时显示)
> {描述}
```

-   **`[图标]`**:
    -   `[ ]`: 待处理
    -   `[-]`: 进行中
    -   `[x]`: 已完成
    -   `[!]`: 失败
-   **`{id}`**: 完整的任务 ID（例如，`15` 或 `15.1`）。
-   **`{状态注释}`**:
    -   `(失败)`: 如果状态为 `failed`。
-   **`依赖`**: 如果 YAML 中的 `dependencies` 列表为空或 null，则省略此行。ID 是完整的任务 ID（例如，`1`，`4.2`）。
-   **`描述`**: 从任务文件的 `## 描述` 部分提取。

**`TASKS.md` 条目示例:**

```markdown
- [-] **ID 15.1: 实现用户登录 API** (优先级: critical)
> 依赖: 1, 4.2
> 允许用户通过 API 使用电子邮件和密码登录。
```

## 工作流程

详细流程见 docs/workflow.md，或见下方流程图。

```mermaid
graph TD
    A[用户请求：从计划/PRD生成任务] --> B[规划所有任务（识别需拆分的复杂任务）]
    B --> B1{是否有任务需要拆分}
    B1 -- 是 --> B2[定义子任务并更新父任务（父任务详情中列出子任务）]
    B1 -- 否 --> C[更新 .ai/TASKS.md，包含所有计划任务（父任务和子任务）]
    B2 --> C
    C --> D[遍历 .ai/TASKS.md 中的每个任务（父任务或子任务）]
    D --> E[在 .ai/tasks/ 中创建/更新单独任务文件]
    E --> F[填充任务文件的 YAML 和 Markdown（父任务文件更新为父状态并列出子任务）]
    F --> G[所有任务文件已创建/更新]
    G --> H{用户要求代理开始工作？}
    H -- 是 --> I[代理读取 TASKS.md，找到第一个待处理任务]
    I --> J{检查所选任务的依赖}
    J -- 已满足 --> K[更新任务文件 YAML 状态为 inprogress]
    K --> L[更新 TASKS.md 进度标记]
    L --> M[执行任务]
    M -- 成功 --> N[更新 YAML 状态为 completed]
    N --> O[更新 TASKS.md 为已完成标记]
    M -- 失败 --> P[更新 YAML 状态为 failed，添加 error_log]
    P --> Q[更新 TASKS.md 为失败标记]
    J -- 未满足 --> R[通知用户：依赖未满足]
    S{用户要求归档？} --> T[代理查找 .ai/tasks/ 中已完成/失败的任务]
    T --> U[移动任务文件到 .ai/memory/tasks/]
    U --> V[追加摘要到 .ai/memory/TASKS_LOG.md]
    V --> W[从 .ai/TASKS.md 中移除对应条目]
```

**关键代理职责:**

1.  **同步:** 让 `.ai/TASKS.md` 与 `.ai/tasks/*.md` 文件中的 `status` 字段完全一致。在更新任务文件的 YAML 状态后*立即*更新 `TASKS.md`。
2.  **依赖检查:** 在将任务的状态更改为 `inprogress`（**在 `TASKS.md` 中将其标识为待处理之后**）之前，验证其 `dependencies` 中列出的*每个* ID 是否对应于 YAML 中 `status: completed` 的任务文件（在 `.ai/tasks/` 或 `.ai/memory/tasks/` 中）。ID 可以是数字（例如，`12`）或字符串（例如，`12.1`）。**如果未满足，代理不能开始任务，必须通知用户。**
3.  **状态更新:**
    *   **开始:** 更新任务文件 YAML（`status: inprogress`，`assigned_agent`，`started_at`）。更新 `TASKS.md` 行（`[-]`）。
    *   **完成:** 更新任务文件 YAML（`status: completed`，`assigned_agent: null`，`completed_at`）。更新 `TASKS.md` 行（`[x]`）。
    *   **失败:** 更新任务文件 YAML（`status: failed`，`assigned_agent: null`，`completed_at`，`error_log`）。更新 `TASKS.md` 行（`[!]`，添加 `(失败)`）。
4.  **存档:** 当用户指示时（解释如"存档已完成任务"，"清理已完成任务"的意图），执行存档步骤：
    *   通过读取其 YAML 状态在 `.ai/tasks/` 中找到已完成/失败的任务（对于通过 `list_dir` 在 `.ai/tasks/` 中识别的每个任务文件使用 `read_file`）。
    *   对于每个要存档的任务：
        *   使用 `read_file` 读取其完整内容（YAML 前置元数据和描述部分）**（这是记录到 TASKS_LOG.md 所需的）。**
        *   **确定源路径（例如，`.ai/tasks/task{id}_name.md`）和目标目录（`.ai/memory/tasks/`）。**
        *   **确保目标目录 `.ai/memory/tasks/` 存在（例如，使用 `list_dir` 或 `file_search`）。如果不存在，通常会在使用 `edit_file` 向其中写入文件时创建它，或者 `mv` 命令可能会创建它。**
        *   **使用 `run_terminal_cmd` 执行 `mv` 命令（例如，`mv .ai/tasks/task{id}_name.md .ai/memory/tasks/`）。**
    *   通过读取其当前内容，附加新的日志条目，并使用 `edit_file` 将其写回，将摘要（包括描述和依赖）记录到 `TASKS_LOG.md`。
    *   通过 `read_file` 和 `edit_file` 从 `.ai/TASKS.md` 中删除相应的条目。 

## `TASKS_LOG.md` 格式

存档时，为每个任务向 `.ai/memory/TASKS_LOG.md` 追加一个条目。如果作为单个用户请求的一部分存档多个任务（批量存档），对该批次中的所有条目使用*相同的*时间戳（在操作开始时获取一次）。

**在移动文件之前提取任务标题、描述（从 markdown 正文）和依赖关系（从 YAML）。**

```markdown
- 已存档 **ID {id}: {标题}** (状态: {completed/failed}) 于 {YYYY-MM-DDTHH:MM:SSZ}
> 依赖: {dep_id1}, {dep_id2}... (仅在 YAML 中存在依赖时显示，使用完整 ID 如 15 或 15.1)
> {描述} (从任务文件中提取)
```

## 代理命令解释

代理应解释用户请求并将其映射到以下动作。在引用任务时使用完整的任务 ID（顶级任务使用数字，子任务使用字符串如 "7.1"）。

*   **显示/列出任务:** 读取并显示 `.ai/TASKS.md` 的当前内容。
*   **创建任务 / 创建子任务:**
    *   **如果创建常规顶级任务或多个任务（从计划/PRD）:**
        *   首先，计划要创建的所有任务，确定其 ID、标题、优先级、依赖关系和描述。
        *   使用 `read_file` 和 `edit_file` 更新 `.ai/TASKS.md` 以包含所有计划任务的条目。
        *   然后，对于现在在 `.ai/TASKS.md` 中列出的每个任务，使用 `edit_file` 在 `.ai/tasks/` 中创建单独的 `task{id}_descriptive_name.md` 文件，填充 YAML 和 markdown 正文。
    *   **如果为现有的 `parent_id` 创建子任务（基于 `@expand.mdc` 或用户的建议）:**
        *   遵循相同的过程：计划所有子任务，使用所有子任务条目更新 `.ai/TASKS.md`，然后在 `.ai/tasks/` 中创建每个 `task{parent_id}.{sub_id}_descriptive_name.md` 文件。
        *   使用 `edit_file` 更新父任务文件的描述和详细信息以列出新的子任务。
        *   如果父任务的描述需要更改，使用 `read_file` 和 `edit_file` 更新 `TASKS.md` 中父任务的条目。
*   **开始/处理下一个任务 / 继续:**
    *   读取 `.ai/TASKS.md` 并识别列出的**第一个**带有 `[ ]`（待处理）图标的任务。
    *   如果找不到待处理的任务，通知用户。
    *   如果找到待处理的任务，继续检查其依赖关系（如果需要，通过读取任务文件）。
    *   如果依赖得到满足：更新任务文件 YAML（`status: inprogress` 等）并更新 `TASKS.md` 中相应的行为 `[-]`。宣布正在开始哪个任务。
    *   如果依赖未得到满足：通知用户，说明哪个任务被阻塞以及缺少哪些依赖。
*   **开始/处理特定任务 {id}:**
    *   验证任务 {id}（例如，`15` 或 `15.1`）存在于 `.ai/TASKS.md` 中，且其状态为 `[ ]`（待处理）。如果不是，通知用户。
    *   检查任务 {id} 的依赖关系。
    *   如果满足：更新任务 {id} YAML（`status: inprogress` 等）并更新 `TASKS.md`。
    *   如果不满足：通知用户缺少依赖。
*   **验证任务完成（强制完成前步骤）:**
    *   **始终**在完成实现工作后检查任务文件（例如，`task{id}_name.md`）是否包含 `## 测试策略` 部分。
    *   如果存在 `## 测试策略` 部分：**不要**立即将任务标记为完成。您**必须**明确询问用户："此任务有测试策略。您想运行测试（最好是通过触发调度命令/操作（如适用）），还是应该基于您的验证将其标记为完成？"
    *   如果不存在 `## 测试策略` 部分，或者用户在被问及测试后确认：继续"完成任务 {id}"步骤。
*   **完成任务 {id}:**
    *   **清理:** 在标记为完成之前，审查为此任务所做的代码更改，并删除为调试或测试目的添加的任何临时日志记录或打印语句（例如，特定于语言的调试打印，详细的控制台日志）。仅保留对生产监控必不可少的日志（例如，错误，关键警告）。
    *   **更新:** 更新任务 {id} YAML（`status: completed`，`assigned_agent: null`，`completed_at`）并更新 `TASKS.md` 中相应的行为 `[x]`。
*   **失败任务 {id} "{原因}":** 更新任务 {id} YAML（`status: failed`，`error_log` 等）并更新 `TASKS.md`。
*   **显示任务 {id} 详情:** 读取 `task{id}_name.md` 的完整内容（YAML 和 Markdown）（检查 `.ai/tasks` 和 `.ai/memory/tasks` 中是否有像 `task15_...md` 或 `task15.1_...md` 这样的文件）并显示它。
*   **存档任务:**
    *   在 `.ai/tasks/` 中识别 YAML 中 `status: completed` 或 `status: failed` 的任务（对 `.ai/tasks/` 中的每个任务使用 `list_dir` 然后 `read_file` 检查状态）。
    *   对于每个识别的任务文件：
        * 使用 `read_file` 读取其 YAML 前置元数据（获取标题、状态、依赖关系）和其 Markdown 正文（获取描述）。
    *   移动已识别的文件：
        *   **构建源路径（例如，`.ai/tasks/task{id}_name.md`）和目标目录（`.ai/memory/tasks/`）。**
        *   **确保目标目录 `.ai/memory/tasks/` 存在（例如，使用 `list_dir` 或 `file_search`）。如果不存在，通常会在使用 `edit_file` 向其中写入文件时创建它，或者 `mv` 命令可能会创建它。**
        *   **使用 `run_terminal_cmd` 执行 `mv` 命令（例如，`mv .ai/tasks/task{id}_name.md .ai/memory/tasks/`）。**
    *   使用新格式（标题、状态、时间戳、依赖、描述）通过 `read_file` 和 `edit_file` 向 `.ai/memory/TASKS_LOG.md` 追加条目。
    *   通过 `read_file` 和 `edit_file` 从 `.ai/TASKS.md` 中删除相应的条目。

## 实用工具

**生成时间戳:**

**代理必须始终使用提供的实用工具获取 `created_at`、`started_at` 和 `completed_at` 字段的当前 UTC 时间戳。永远不要硬编码或猜测日期/时间。**

使用以下命令获取当前 UTC 时间戳：

```bash
date -u +"%Y-%m-%dT%H:%M:%SZ"
```

此命令预期能成功执行（整体退出代码 0）。输出将在第一行包含时间戳，然后是一行指示 `date` 命令本身的特定退出代码（例如，"Date_Command_Exit_Code: 0"）。代理应该使用输出的第一行中的时间戳。 